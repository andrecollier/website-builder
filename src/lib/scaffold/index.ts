/**
 * Scaffold Generator
 *
 * Creates a complete runnable Next.js project from generated components
 * in the Websites/<id>/generated/ folder.
 */

import fs from 'fs';
import path from 'path';

interface ScaffoldOptions {
  websiteId: string;
  websitesDir: string;
  siteName?: string;
}

/**
 * Get the package.json template
 */
function getPackageJson(siteName: string): string {
  return JSON.stringify({
    name: siteName.toLowerCase().replace(/\s+/g, '-'),
    version: "1.0.0",
    private: true,
    scripts: {
      dev: "next dev -p 3002",
      build: "next build",
      start: "next start -p 3002",
      lint: "next lint"
    },
    dependencies: {
      "next": "14.2.21",
      "react": "^18.2.0",
      "react-dom": "^18.2.0"
    },
    devDependencies: {
      "@types/node": "^20",
      "@types/react": "^18",
      "@types/react-dom": "^18",
      "autoprefixer": "^10.4.20",
      "postcss": "^8.5.3",
      "tailwindcss": "^3.4.17",
      "typescript": "^5"
    }
  }, null, 2);
}

/**
 * Get the tsconfig.json template
 */
function getTsConfig(): string {
  return JSON.stringify({
    compilerOptions: {
      lib: ["dom", "dom.iterable", "esnext"],
      allowJs: true,
      skipLibCheck: true,
      strict: true,
      noEmit: true,
      esModuleInterop: true,
      module: "esnext",
      moduleResolution: "bundler",
      resolveJsonModule: true,
      isolatedModules: true,
      jsx: "preserve",
      incremental: true,
      plugins: [{ name: "next" }],
      paths: { "@/*": ["./src/*"] }
    },
    include: ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
    exclude: ["node_modules"]
  }, null, 2);
}

/**
 * Get next.config.js template
 */
function getNextConfig(): string {
  return `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;
`;
}

/**
 * Get postcss.config.js template
 */
function getPostCssConfig(): string {
  return `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
`;
}

/**
 * Get tailwind.config.js template (basic)
 */
function getTailwindConfig(): string {
  return `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
`;
}

/**
 * Get globals.css template
 */
function getGlobalsCss(): string {
  return `@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
`;
}

/**
 * Get layout.tsx template
 */
function getLayout(siteName: string): string {
  return `import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: '${siteName}',
  description: 'Generated by Website Cooker',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
`;
}

/**
 * Generate page.tsx that renders all components
 */
function getPageTsx(componentNames: string[]): string {
  const imports = componentNames
    .map(name => `import { ${name} } from '@/components/${name}';`)
    .join('\n');

  const components = componentNames
    .map(name => `      <${name} />`)
    .join('\n');

  return `${imports}

export default function Home() {
  return (
    <main className="min-h-screen">
${components}
    </main>
  );
}
`;
}

/**
 * Copy directory recursively
 */
function copyDirRecursive(src: string, dest: string): void {
  if (!fs.existsSync(src)) return;

  fs.mkdirSync(dest, { recursive: true });

  const entries = fs.readdirSync(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

/**
 * Get list of component names from current/src/components
 */
function getComponentNames(componentsDir: string): string[] {
  if (!fs.existsSync(componentsDir)) return [];

  return fs.readdirSync(componentsDir, { withFileTypes: true })
    .filter(entry => entry.isDirectory())
    .map(entry => entry.name);
}

/**
 * Scaffold a complete Next.js project in generated/ folder
 */
export async function scaffoldGeneratedSite(options: ScaffoldOptions): Promise<{
  success: boolean;
  generatedPath: string;
  error?: string;
}> {
  const { websiteId, websitesDir, siteName = 'Generated Site' } = options;

  const websiteDir = path.join(websitesDir, websiteId);
  const currentDir = path.join(websiteDir, 'current');
  const generatedDir = path.join(websiteDir, 'generated');
  const componentsSourceDir = path.join(currentDir, 'src', 'components');

  try {
    // Check if components exist
    if (!fs.existsSync(componentsSourceDir)) {
      return {
        success: false,
        generatedPath: generatedDir,
        error: 'No components found in current/src/components',
      };
    }

    // Get component names
    const componentNames = getComponentNames(componentsSourceDir);
    if (componentNames.length === 0) {
      return {
        success: false,
        generatedPath: generatedDir,
        error: 'No components found',
      };
    }

    // Create generated directory
    if (fs.existsSync(generatedDir)) {
      fs.rmSync(generatedDir, { recursive: true });
    }
    fs.mkdirSync(generatedDir, { recursive: true });

    // Create directories
    fs.mkdirSync(path.join(generatedDir, 'src', 'app'), { recursive: true });
    fs.mkdirSync(path.join(generatedDir, 'src', 'components'), { recursive: true });

    // Write config files
    fs.writeFileSync(path.join(generatedDir, 'package.json'), getPackageJson(siteName));
    fs.writeFileSync(path.join(generatedDir, 'tsconfig.json'), getTsConfig());
    fs.writeFileSync(path.join(generatedDir, 'next.config.js'), getNextConfig());
    fs.writeFileSync(path.join(generatedDir, 'postcss.config.js'), getPostCssConfig());
    fs.writeFileSync(path.join(generatedDir, 'tailwind.config.js'), getTailwindConfig());

    // Write app files
    fs.writeFileSync(path.join(generatedDir, 'src', 'app', 'globals.css'), getGlobalsCss());
    fs.writeFileSync(path.join(generatedDir, 'src', 'app', 'layout.tsx'), getLayout(siteName));
    fs.writeFileSync(path.join(generatedDir, 'src', 'app', 'page.tsx'), getPageTsx(componentNames));

    // Copy components from current/ to generated/
    copyDirRecursive(componentsSourceDir, path.join(generatedDir, 'src', 'components'));

    // Copy design system files if they exist
    const designSystemPath = path.join(websiteDir, 'design-system.json');
    if (fs.existsSync(designSystemPath)) {
      fs.copyFileSync(designSystemPath, path.join(generatedDir, 'design-system.json'));
    }

    // Copy variables.css if it exists
    const variablesCssPath = path.join(websiteDir, 'variables.css');
    if (fs.existsSync(variablesCssPath)) {
      // Append to globals.css
      const variablesCss = fs.readFileSync(variablesCssPath, 'utf-8');
      const globalsPath = path.join(generatedDir, 'src', 'app', 'globals.css');
      fs.appendFileSync(globalsPath, '\n\n/* Design System Variables */\n' + variablesCss);
    }

    // Run npm install
    const { execSync } = await import('child_process');
    try {
      execSync('npm install', {
        cwd: generatedDir,
        stdio: 'pipe',
        timeout: 120000, // 2 minute timeout
      });
    } catch (npmError) {
      console.warn('npm install warning:', npmError instanceof Error ? npmError.message : 'Unknown npm error');
      // Continue even if npm install has warnings
    }

    return {
      success: true,
      generatedPath: generatedDir,
    };
  } catch (error) {
    return {
      success: false,
      generatedPath: generatedDir,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
